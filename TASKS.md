# Технічні задачі Calendary

## Як користуватись цим файлом

1. **Запуск задачі**: Скопіюйте опис задачі та дайте AI помічнику (Claude/Copilot/Gemini/Codex)
2. **AI виконує**: Помічник створить бренчу, напише код, протестує
3. **Тестування**: Використовуйте чек-лист з секції "Що тестувати"
4. **Завершення**: AI створить commit та PR (або ви це зробите вручну)
5. **Позначка**: Позначте задачу як виконану (змініть статус на DONE)

---

## Легенда статусів

- **TODO** - задача не розпочата
- **IN PROGRESS** - задача в роботі
- **TESTING** - задача потребує тестування
- **DONE** - задача виконана та змерджена

---

## Високий пріоритет (P1)

### 1. Оптимізація генерації PDF календарів
**Статус**: TODO
**Складність**: Висока
**Час**: 4-6 годин

**Проблема**:
Генерація PDF для календарів займає 10-15 секунд для календаря з 12 зображеннями високої якості.

**Що треба зробити**:
1. Проаналізувати `PdfService` в `Calendary.Core/Services`
2. Оптимізувати завантаження зображень (паралельна обробка)
3. Використовувати кешовані thumbnail версії замість повнорозмірних
4. Додати progress bar для користувача (WebSocket або SignalR)
5. Розглянути можливість фонової генерації через RabbitMQ

**Файли для зміни**:
- `src/Calendary.Core/Services/PdfService.cs`
- `src/Calendary.Api/Controllers/CalendarController.cs`
- Можливо: додати новий Consumer в `Calendary.Consumer`

**Що тестувати**:
- [ ] Генерація PDF завершується за <5 секунд
- [ ] Якість зображень в PDF не погіршилась
- [ ] Правильне відображення дат та мови
- [ ] Тестувати з 12 зображеннями різних розмірів (1MB, 5MB, 10MB)
- [ ] Навантажувальне тестування: 10 одночасних генерацій

**Критерії успіху**:
- Час генерації зменшився на 50%+
- Не виникає помилок при паралельних запитах

---

### 2. Обробка помилок Replicate API з retry logic
**Статус**: TODO
**Складність**: Середня
**Час**: 3-4 години

**Проблема**:
При збоях Replicate API (timeout, 5xx errors) тренування або генерація просто падає без retry.

**Що треба зробити**:
1. Додати Polly library для retry policies
2. Реалізувати exponential backoff для Replicate API викликів
3. Додати fallback механізм (збереження в чергу для повторної спроби)
4. Логувати всі retry спроби
5. Показувати користувачу статус "Retrying..." замість "Failed"

**Файли для зміни**:
- `src/Calendary.Core/Services/ReplicateService.cs`
- `src/Calendary.Core/Calendary.Core.csproj` (додати Polly NuGet)
- `src/Calendary.Consumer/Consumers/*` (для обробки повторних спроб)

**Що тестувати**:
- [ ] Симулювати Replicate timeout (відключити інтернет)
- [ ] Перевірити що є 3 retry спроби з затримками (1s, 2s, 4s)
- [ ] Статус в БД оновлюється коректно (retrying -> succeeded/failed)
- [ ] Логи містять інформацію про кожну спробу
- [ ] Користувач бачить прогрес в UI

**Критерії успіху**:
- 90%+ тренувань з тимчасовими збоями завершуються успішно після retry

---

### 3. Валідація завантажених фото
**Статус**: TODO
**Складність**: Середня
**Час**: 2-3 години

**Проблема**:
Користувачі можуть завантажити неякісні фото, що призводить до поганих результатів тренування.

**Що треба зробити**:
1. Перевірка формату (тільки JPG, PNG, WebP)
2. Перевірка розміру (мін 512x512px, макс 4096x4096px)
3. Перевірка розміру файлу (макс 10MB на фото)
4. Перевірка мінімальної кількості (10-30 фото)
5. Опціонально: NSFW detection (можна використати Azure Content Moderator API)
6. Показувати зрозумілі помилки користувачу

**Файли для зміни**:
- `src/Calendary.Api/Controllers/FluxModelController.cs` (або відповідний контролер)
- Додати `src/Calendary.Core/Services/ImageValidationService.cs`
- `src/Calendary.Ng/src/app/components/` - UI для відображення помилок

**Що тестувати**:
- [ ] Завантаження BMP/GIF/TIFF файлів відхиляється
- [ ] Завантаження фото <512px показує помилку
- [ ] Завантаження файлу >10MB показує помилку
- [ ] Завантаження <10 фото показує попередження
- [ ] Показуються зрозумілі повідомлення українською та англійською

**Критерії успіху**:
- Менше failed тренувань через погані фото (зменшення на 70%+)

---

### 4. Кешування результатів Replicate API
**Статус**: TODO
**Складність**: Середня
**Час**: 2-3 години

**Проблема**:
Ідентичні промпти з однаковим seed генерують знову замість використання кешу.

**Що треба зробити**:
1. Додати кеш в пам'яті або Redis
2. Ключ кешу: `{modelVersion}:{prompt}:{seed}` → `imageUrl`
3. TTL: 30 днів
4. Перевірка перед викликом Replicate: якщо є в кеші - повернути відразу
5. Зберігати в БД (`GeneratedImages` таблиця) для постійного кешу

**Файли для зміни**:
- `src/Calendary.Core/Services/ReplicateService.cs`
- Додати `src/Calendary.Repos/Repositories/GeneratedImageRepository.cs`
- Можливо: додати Redis в `docker-compose.yml`

**Що тестувати**:
- [ ] Перша генерація з промптом "A" і seed 123 викликає Replicate
- [ ] Друга генерація з тими ж параметрами повертає кеш (<100ms)
- [ ] Генерація з іншим seed або промптом викликає Replicate знову
- [ ] Кеш не ламається при рестарті сервера (якщо використовується БД)

**Критерії успіху**:
- 40%+ запитів повертаються з кешу
- Економія коштів на Replicate API

---

## Середній пріоритет (P2)

### 5. Unit тести для Core сервісів
**Статус**: TODO
**Складність**: Середня
**Час**: 4-5 годин

**Що треба зробити**:
1. Налаштувати xUnit test project
2. Написати тести для `ReplicateService`:
   - `CreateModelAsync` - успішне створення
   - `TrainModelAsync` - різні статуси (starting, processing, succeeded, failed)
   - `GenerateImageAsync` - успішна генерація
3. Написати тести для `PdfService`:
   - Генерація PDF з різними даними
4. Використовувати Moq для мокування HttpClient, DbContext
5. Покриття мінімум 70%

**Файли для створення**:
- `tests/Calendary.Core.Tests/Services/ReplicateServiceTests.cs`
- `tests/Calendary.Core.Tests/Services/PdfServiceTests.cs`

**Що тестувати**:
- [ ] Всі тести проходять: `dotnet test`
- [ ] Coverage report показує >70% покриття

**Критерії успіху**:
- CI/CD pipeline запускає тести автоматично
- Новий код не merge без тестів

---

### 6. Структуроване логування з Serilog
**Статус**: TODO
**Складність**: Низька
**Час**: 2-3 години

**Що треба зробити**:
1. Додати Serilog NuGet packages
2. Налаштувати Sinks: Console, File, Seq (опціонально)
3. Логувати всі API requests/responses (middleware)
4. Логувати Replicate API виклики
5. Логувати помилки з stack trace
6. Structured logging: `Log.Information("User {UserId} created order {OrderId}", userId, orderId)`

**Файли для зміни**:
- `src/Calendary.Api/Program.cs`
- `src/Calendary.Api/Calendary.Api.csproj` (додати Serilog)
- Додати middleware для request logging

**Що тестувати**:
- [ ] Логи з'являються в консолі при запитах
- [ ] Логи зберігаються у файл `logs/calendary-.log`
- [ ] Structured data правильно серіалізується (JSON format)

**Критерії успіху**:
- Легко знайти помилки за OrderId або UserId
- Логи доступні для аналізу

---

### 7. Rate limiting для публічних API endpoints
**Статус**: TODO
**Складність**: Низька
**Час**: 1-2 години

**Що треба зробити**:
1. Додати AspNetCoreRateLimit NuGet
2. Налаштувати rate limits:
   - `/api/auth/register`: 5 запитів/годину на IP
   - `/api/flux-models/train`: 3 запити/день на користувача
   - `/api/synthesis/generate`: 100 запитів/годину на користувача
3. Повертати 429 Too Many Requests з Retry-After header
4. Показувати зрозумілу помилку на фронтенді

**Файли для зміни**:
- `src/Calendary.Api/Program.cs`
- `src/Calendary.Api/appsettings.json` (конфігурація rate limits)

**Що тестувати**:
- [ ] Перевищення ліміту реєстрації повертає 429
- [ ] Після Retry-After часу запит знову працює
- [ ] Різні користувачі мають окремі ліміти

**Критерії успіху**:
- Захист від spam реєстрацій
- Економія на Replicate API (обмеження зловживань)

---

### 8. Оптимізація запитів до БД (N+1 problem)
**Статус**: TODO
**Складність**: Середня
**Час**: 3-4 години

**Що треба зробити**:
1. Увімкнути SQL logging в EF Core (тільки на dev)
2. Знайти всі N+1 проблеми (аналіз логів)
3. Використовувати `.Include()` та `.ThenInclude()` для eager loading
4. Додати `.AsNoTracking()` для read-only запитів
5. Розглянути використання compiled queries для часто використовуваних

**Файли для зміни**:
- `src/Calendary.Repos/Repositories/*.cs`
- `src/Calendary.Core/Services/*.cs` (якщо там є прямі запити)

**Що тестувати**:
- [ ] Включити SQL logging і перевірити що для списку Orders не більше 3-4 SQL запитів
- [ ] Навантажувальне тестування: час відповіді GET /api/orders <200ms

**Критерії успіху**:
- Зменшення кількості SQL запитів на 50%+
- Покращення швидкості API на 30%+

---

## Низький пріоритет (P3)

### 9. Міграція на .NET 10
**Статус**: TODO (чекає релізу .NET 10)
**Складність**: Низька
**Час**: 1-2 години

**Що треба зробити**:
1. Оновити всі `.csproj`: `<TargetFramework>net10.0</TargetFramework>`
2. Оновити NuGet пакети до найновіших версій
3. Запустити тести
4. Перевірити breaking changes в офіційних release notes

**Що тестувати**:
- [ ] dotnet build успішний
- [ ] Всі тести проходять
- [ ] API працює як раніше

---

### 10. Додавання нових промпт тем
**Статус**: TODO
**Складність**: Низька
**Час**: 1-2 години

**Що треба зробити**:
1. Додати сезонні теми: Christmas, Halloween, New Year, Summer vacation
2. Додати професійні теми: Business, Formal, Casual
3. Зберігати в `PromptThemes` таблицю
4. UI для вибору теми при генерації

**Файли для зміни**:
- `src/Calendary.Repos/Migrations/` - додати seed data
- `src/Calendary.Ng/src/app/components/` - UI для вибору

**Що тестувати**:
- [ ] Нові теми відображаються в dropdown
- [ ] Генерація з темою працює коректно

---

### 11. Multilanguage підтримка UI
**Статус**: TODO
**Складність**: Середня
**Час**: 3-4 години

**Що треба зробити**:
1. Додати ngx-translate в Angular
2. Створити файли перекладів: `en.json`, `uk.json`
3. Перекласти всі текстові рядки
4. Додати language switcher в header

**Файли для створення**:
- `src/Calendary.Ng/src/assets/i18n/uk.json`
- `src/Calendary.Ng/src/assets/i18n/en.json`

**Що тестувати**:
- [ ] Перемикання мови оновлює всі тексти
- [ ] Мова зберігається в localStorage

---

### 12. Mobile app (React Native / Flutter)
**Статус**: TODO
**Складність**: Дуже висока
**Час**: 40-60 годин

**Що треба зробити**:
1. Обрати технологію (React Native або Flutter)
2. Створити новий проект
3. Реалізувати авторизацію
4. Реалізувати завантаження фото
5. Реалізувати перегляд згенерованих зображень
6. Опублікувати в Google Play / App Store

(Детальний roadmap окремо)

---

## Bugfix задачі

### BUG-1: WebHook від MonoPay іноді не спрацьовує
**Статус**: TODO
**Складність**: Середня

**Проблема**:
Іноді після оплати замовлення статус не оновлюється автоматично.

**Що перевірити**:
1. Чи правильний WebhookUrl в налаштуваннях MonoPay
2. Чи обробляється WebHook endpoint коректно
3. Додати логування всіх вхідних WebHook запитів
4. Додати retry mechanism якщо обробка падає

**Файли**:
- `src/Calendary.Api/Controllers/WebhookController.cs`

---

### BUG-2: Seed не зберігається коректно після генерації
**Статус**: TODO
**Складність**: Низька

**Проблема**:
Поле `OutputSeed` в таблиці `Synthesis` іноді залишається null.

**Що зробити**:
1. Перевірити парсинг seed з Replicate logs
2. Додати fallback: якщо seed не знайдено в logs - використати input seed
3. Додати валідацію перед збереженням

**Файли**:
- `src/Calendary.Core/Services/ReplicateService.cs` (метод `ExtractSeedFromLogs`)

---

## Інфраструктурні задачі

### INFRA-1: Налаштування CI/CD pipeline
**Статус**: TODO
**Складність**: Середня
**Час**: 3-4 години

**Що треба зробити**:
1. GitHub Actions для автоматичного build
2. Запуск тестів на кожен PR
3. Автоматичний deploy на staging після merge в main
4. Автоматичний deploy на production після тега (v1.0.0)

**Файли для створення**:
- `.github/workflows/build.yml`
- `.github/workflows/deploy-staging.yml`
- `.github/workflows/deploy-production.yml`

---

### INFRA-2: Docker production setup
**Статус**: TODO
**Складність**: Середня
**Час**: 2-3 години

**Що треба зробити**:
1. Оптимізувати Dockerfile (multi-stage build)
2. Додати health check endpoints
3. Налаштувати docker-compose для production
4. Додати reverse proxy (nginx)

**Файли**:
- `Dockerfile.production`
- `docker-compose.production.yml`
- `nginx.conf`

---

## Як додати нову задачу

```markdown
### [ID]. [Назва задачі]
**Статус**: TODO
**Складність**: Низька/Середня/Висока/Дуже висока
**Час**: X-Y годин

**Проблема**:
Опис проблеми яку вирішуємо

**Що треба зробити**:
1. Крок 1
2. Крок 2
3. ...

**Файли для зміни**:
- файл 1
- файл 2

**Що тестувати**:
- [ ] Тест 1
- [ ] Тест 2

**Критерії успіху**:
- Метрика 1
- Метрика 2
```

---

**Останнє оновлення**: 2025-11-15
